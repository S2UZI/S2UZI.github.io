---
title:  "[3장] 함수"
excerpt: "가장 기본적인 단위인 함수를 잘 만드는 법"

categories:
  - Clean Code
tags:
  - [Clean Code]

permalink: /web/clean-code/3

toc: true
toc_sticky: true
 
date: 2022-06-28
last_modified_at: 2022-06-28
---
3장에서는 가장 기본적인 단위인 함수를 잘 만드는 법을 소개한다.


## 함수를 작게 만들어라
함수를 최대한 작게 만들자!
```java
public static String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) throws Exception {
	boolean isTestPage = pageData.hasAttribute("Test"); 
	if (isTestPage) {
		WikiPage testPage = pageData.getWikiPage(); 
		StringBuffer newPageContent = new StringBuffer(); 
		includeSetupPages(testPage, newPageContent, isSuite); 
		newPageContent.append(pageData.getContent()); 
		includeTeardownPages(testPage, newPageContent, isSuite); 
		pageData.setContent(newPageContent.toString());
	}
	return pageData.getHtml(); 
} 
)
```
위 코드도 한번 리팩토링 한 버전인데 그래도 길다. 더 짧게 만들자.
```java
public static String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) throws Exception { 
   if (isTestPage(pageData)) 
   	includeSetupAndTeardownPages(pageData, isSuite); 
   return pageData.getHtml();
}
```
- if문 while 문 등에 들어가는 블록은 한 줄이어야 한다. -> 보통 거기서 함수를 호출
  -  바깥을 감싸는 함수가 작아진다.
  -  블록 안에서 호출하는 함수 이름을 적절히 짓는다면, 코드 이해도 쉬워진다.
- 중첩 구조가 생길 만큼 함수가 커져선 안된다.
- 들여쓰기 수준은 1단이나 2단을 넘어서면 가독성이 떨어진다.

<br>

## 한 가지만 해라!
 함수는 <mark>한 가지</mark>를 해야하고 <mark>한 가지</mark>를 잘해야한다
- '한 가지' 구분
  - 추상화 수준에서 한 단계만 수행
  - 의미 있는 이름으로 다른 함수를 추출할 수 있다면 한 가지X
  - 한 함수에서 여러 섹션으로 나뉜다면 여러가지 작업을 하는 함수

<br>

## 함수 당 추상화 수준은 동일!
함수가 확실하게 한가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야한다. 특정표현이 <mark>근본개념</mark>인지 <mark>세부사항</mark>인지 구분해야한다.

### 내려가기 규칙
코드는 위에서 아래로 이야기처럼 읽여햐 좋다. 한 함수 다음에는 추상화 수준이 한단계 낮은 함수가 온다. 즉, 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아지는데 이것을 <mark>내려가기</mark> 규칙이라 부른다. 다르게 표현하면, 일련의 TO문단 (~하려면) 읽듯이 프로그램이 읽혀야 한다는 의미이다.

<mark>예시</mark>
```
To 설정 페이지와 해체 페이지를 포함하려면, 설정 페이지를 포함하고, 테스트 페이지 내용을 포함하고, 해제 페이지를 포함한다.
  To 설정 페이지를 포함하려면, 슈트이면 슈트 설정 페이지를 포함한 후 일반 설정 페이지를 포함한다.
  To 슈트 설정 페이지를 포함하려면, 부모 계층에서 "SuiteSetUp" 페이지를 찾아 include 문과 페이지 경로를 추가한다.
  To 부모 계층을 검색하려면 ~~
  ```

<br>

## 함수 잘 만드는 법
swith 문은 작게 만들이 어렵다. 본질적으로 N가지를 처리하기 때문이다.
```java
public Money calculatePay(Employee e) throws InvalidEmployeeType {
    switch (e.type) { 
		case COMMISSIONED:
			return calculateCommissionedPay(e); 
		case HOURLY:
			return calculateHourlyPay(e); 
		case SALARIED:
			return calculateSalariedPay(e); 
		default:
			throw new InvalidEmployeeType(e.type); 
	}
}
```
**위 함수의 문제점**
- 함수가 길다 -> 직원 추가할때마다 길어짐
- 한가지 작업만 수행X
- SRP(Single Responsibility Principle,단일 책임 원칙) 위반 
- OCP(Open Closed Principle,확장엔 열려있어야하고 수정에 닫혀 있어야한다.)위반
  

<mark>좋은 코드</mark>
```java
public abstract class Employee {
	public abstract boolean isPayday();
	public abstract Money calculatePay();
	public abstract void deliverPay(Money pay);
}


public interface EmployeeFactory {
	public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType; 
}


public class EmployeeFactoryImpl implements EmployeeFactory {
	public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
		switch (r.type) {
			case COMMISSIONED:
				return new CommissionedEmployee(r) ;
			case HOURLY:
				return new HourlyEmployee(r);
			case SALARIED:
				return new SalariedEmploye(r);
			default:
				throw new InvalidEmployeeType(r.type);
		} 
	}
}
```
- switch 문은 저차원 클래스에 숨기고 절대 반복하지 않는다 -> 다형성(Polymorohism) 사용
- switch 문을 추상팩토리에 숨겨서 다형적 객체를 생성하는 코드안에서만 switch 를 사용하도록 한다.

<br>

## 서술적인 이름을 사용하라
- 이름이 길어도 괜찮다. 일관적이고 서술적인 함수 이름으로 수행하는 기능이 무엇인지 그대로 짐작 가능하게 만들어야한다.
- 일관성있게 같은 문구, 명사 동사를 사용한다.

<mark>예시</mark> includeSetUpandTearDownPages, includeSetUpPages, includeSuiteSetUpPage 

<br>

## 함수 인수
**인수** 는 적을 수록 좋다.
- 입력 인수: 인수가 0개가 제일 좋고 차선으로 1개(단항)뿐인 경우
- 출력인수 : 코드를 재차 확인하는 번거로움 발생, 입력 인수가 없은 경우가 최선이다.

### 많이 쓰는 단항형식
1. 인수에 질문을 던지는 경우
   ex) boolean fileExists("MyFile")
2. 인수를 뭔가로 반환해 결과를 반환 하는 경우 
   ex) InputStream fileOpen("MyFile"); 
    string형의 파일 이름을 InputStream으로 변환
3. 이벤트 함수 인 경우 : 이벤트 함수는 입력 인수만 있고 출력 인수는 없다.
   ex) passwordAttemptsNTimes(int attempts);

위와 같은 경우가 아니라면 단항 함수는 가급적 피하는게 좋다.

### 플래그 인수
함수로 부울 값을 넘기는 플래그 인수는 끔찍하다. 함수가 한꺼번에 여러 가지를 처리한다고 공표하는 셈이기 때문이다.

### 이항 함수
**인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다.**

`writeField(name) vs writeField(outputStream, name)`

둘 다 의미는 명백하지만 전자가 더 쉽게 이해할 수 있다.

** 이항 함수가 적절한 경우도 있다. Point class 인 경우 오히려 인사가 1개면 더 놀란다**
`Point p = new Point(1, 1);`
이항 함수가 무조건 나쁘다는 것은 아니다. 불가피한 경우도 있다. 하지만 가능하면 단항함수로 바꾸도록 애써야한다.



---
**Reference**
- 클린코드 , 로버트C. 마틴